Which of the following initializations are legal? Explain why.
(a) int i = -1, &r = 0; `int i` is legal, but `&r` is not as it attempts to bind a reference `r` to the literal `0`. A reference must be bound to an existing object (like a variable), not to a temporary or literal unless it's a `const` reference.
(b) int *const p2 = &i2; This declares `p2` as a `const` pointer to an `int`. Once `p2` is initialized with the address of `i1`, you cannot change `p2` to point to a different variable. You can, however, change the value of the variable that `p2` point to (in this case, `i2`), as long as `i2` is not `const`.
(c) const int i = -1, &r = 0; This is legal, as it solves the error from (a). Here we are declaring `const int &r = 0;`.
(d) const int *const p3 = &i2; This is legal so long as `&i2` is an `int` or `const int`. `const int *const p3` declares `p3` as a `const` pointer to a `const` int`. Once initialized, `p3` cannot point to any other address. Furthermore, the integer value point to by `p3` cannot be modified through `p3`.
(e) const int *p1 = &i2; This is legal. `const int *p1` declares `p1` as a pointer to a `const int`. You can change `p1` to point to another integer, but you cannot modify the value at the address `p1` point to.
(f) const int &const r2; This is not legal in C++. `const int &r2` would declare `r2` as a reference to a `const int`. A reference itself is not an object that can be modified; it's just an alias for another object. You cannot apply `const` to a reference itself because a reference is inherently constant in nature.
(g) const int i2 = i, &r = i; This is legal, assuming `i` is an `int` or `const int`. The reference `r` being `const` means that you cannot modify the value of `i` through `r`, but it does not require `i` to be `const`. The key point is that the `const` in the reference only applies to the reference itself, ensure that the value it references cannot be modified through that reference.